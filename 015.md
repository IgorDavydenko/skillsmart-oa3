## 15. Ещё о важном преимуществе ОО-подхода

Чем плох модульно-функциональный подход? Хоть он и называется функциональным, но полностью завязан на данные, на состояния системы, обработка которых бессистемно размазывается между модулями, наращивая взаимозависимости между ними. Реакции на действия пользователей, ввод и вывод данных, проверка корректности -- все эти операции зависят от статических состояний и подразумевают программирование множества условных цепочек обработки всевозможных вариантов и условий. В таком случае при добавлении, изменении или удалении состояний приходится вносить правки во множество функций и модулей. Кроме того, если некоторый модуль претендует на универсальность, то он должен обрабатывать вообще все мыслимые состояния из соответствующего диапазона.

Такой подход подразумевает, что мы движемся через анализ, проектирование и реализацию логики обработки данных, но как только мы пытаемся организовать потоки данных через такую функциональную логику, возникает множество побочных эффектов, непрозрачность модулей быстро растёт, и в результате запутанность всего проекта стремительно его усложняет и замедляет. Причём данные тут -- лишь некая второстепенная сущность, простая переменная (содержащая обычное значение, в лучшем случае массив или список), которая перебрасывается между функциями. Фактически этим же грешат и многие методики ООП, отводя объектам как хранилищам данных вторичную роль.

Сильный объектно-ориентированный подход предлагает прямо противоположный принцип: мы начинаем именно с проектирования структур данных и взаимосвязей между ними, а функций полностью погружаются в это всё, представляются в виде простых операций над конкретными структурами данных. В ООП мы постепенно детализируем иерархию АТД, пошагово выделяя общие наборы операций, очень чётко формализуя различие между состояниями сущностей системы. Тут даже нередко можно обойтись только неглубоким наследованием (1-2 уровня) и частичной реализацией, без использования композиции или каких-то сложных форм полиморфизма. Мы плавно формируем архитектуру системы, увязывая все сущности (типы данных) в гармонично согласованные структуры.

При этом, конечно, неявно выполняется и функциональная декомпозиция, только теперь соответствующие функции распределяются по строгим семантическим правилам -- попадают непосредственно в те модули (классы), которые специфицируют определённые структуры данных. В самом низу иерархии типов располагаются классы, которые будут весьма похожи на модули с функциями, только теперь такая архитектура спроектирована с помощью формального способа группировки составляющих её элементов (классов), и предоставляет дополнительные мощные механизмы -- полиморфизм, динамическое связывание, инкапсуляцию и т. п. Она умеет развиваться эволюционно, и всю её пронизывает принцип повторного использования кода.

Таким образом, сформированная в итоге система часто отнюдь не моделирует напрямую "реальный мир", и с точки зрения её архитектуры нельзя ответить на вопрос "что она делает?" -- для децентрализованной схемы он бессмысленный. Результат проектирования и реализации мы оцениваем с точки зрения программной инженерии: насколько проста, гибка, масштабируема система, и насколько точно она отвечает проектным спецификациям (которые сами по себе ничуть не менее реальны, нежели "естественно" воспринимаемые сущности). Выбранные проектировщиком спецификации должны конечно обеспечивать моделирование внешней системы, однако они обычно весьма абстрактны и контринтуитивны для неспециалиста. Умение находить и формализовывать такие абстракции, по большому счёту, и есть мастерство проектировщика.

При этом, конечно, на практике нередки ситуации, когда спецификация неоднократно уточняется, исходя из некоторой оптимальной формы реализации или ограничений фреймворка -- тут нету слепой механической реализации спецификаций, возникает своеобразная рекурсия, но это вполне нормальный подход. Более того, весь цикл анализ - проектирование - кодирование пронизан такой обратной связью и естественно подразумевает итерации.

