## 7. Правильная методика проектирования

Правильная методика объектно-ориентированного проектирования и построения масштабируемой объектной архитектуры подразумевает, что у нас имеется большой мир, в котором взаимодействуют друг с другом примерно равноправные сущности (объекты). Он организован не иерархически (как в случае модульной архитектуры), а плоско, и может легко развиваться эволюционно.

Главное в таком проектировании -- это внутренняя семантика такого мира, его содержание, множество маленьких независимых "смыслов", потому что форма (например, наборы типовых сценариев действий пользователей) всегда очень изменчива.

С помощью ООП мы по сути разрабатываем математическую модель, некоторую алгебру -- наборы формальных операций. А вот какую-либо непосредственную композицию (сценарии использования) носителей этой алгебры (объектов с публичным интерфейсом) мы пока откладываем. Но подразумеваем при проектировании АТД, конечно, какую внутреннюю семантику они должны реализовывать.

Таким образом, этот подход можно назвать проектированием "снизу вверх". На первом шаге мы разрабатываем достаточно универсальные компактные компоненты (даже не объекты, а типы, АТД), из которых потом и составляем наше приложение с помощью системы типов. На втором шаге (который неразрывно связан с первым) мы дополняем наборы операций в типах различными ограничениями (семантикой), требованиями предметной области. Но при этом постоянно придерживаемся более высокого уровня абстракции, нежели прозаические классы в коде (а именно, думаем о проекте всё время в терминах АТД), иначе физическая реализация будет ничуть не лучше, чем в случае функционального подхода "сверху вниз".

Объектно-ориентированное проектирование подразумевает конструирование архитектуры системы из модулей, полностью основанных на типах объектов, с которыми ведётся работа в моделируемой предметной области.

По мере реализации проекта мы последовательно улучшаем наше понимание структур нужных классов, поддерживаем на основе спецификаций АТД устойчивые и семантически легко расширяемые понятия, и выполняем сборку всё более мощных и крупных подсистем, пока не будет получена окончательная работающая система. Причём собирать её из итогового набора АТД обычно можно по-разному. Такая сборка в некотором смысле получается автоматически: мы разрабатываем своеобразный симулятор, подобие компьютерной игры, в котором после его старта самостоятельно действует множество равноправных объектов, обмениваясь друг с другом сообщениями (вызывая методы).

Отсюда следует важный принцип проектирования:
не спрашивайте, что система делает; спрашивайте, кто в системе делает то-то и то-то.

Но напомню, что в результате мы всё же хотим получить действующий прототип: по окончании анализа и проектирования вам потребуется добавить минимальную реализацию классов, и чтобы проект в итоге легко и просто собирался, запускался и работал.

Для этого критически важен скилл т.н. поведенческой композиции. Она состоит из трёх неразрывно связанных моментов:

- способность разбивать большое сложное поведение на части;
- рациональная уверенность, что это разбиение будет корректно работать как одно целое;
- организация реализации и тестирования этих частей такое, которое гарантирует, что вся система ведёт себя именно так, как ожидалось.

Это сложный навык, поэтому я порекомендую уже с первых шагов придерживаться схемы разработки TDD. Как минимум, почитайте с курса карьеры "TDD: разработка, управляемая тестированием", а также материалы СильныхИдей "25) Как правильно писать тесты" и "27) Как правильно понимать TDD".

Безусловно, у всех нас есть некоторое представление о том, как поведёт себя система, когда мы "закончим", иначе мы бы не начинали. Но, используя методику Мейера и поведенческую композицию, мы не заботимся о том, как ведёт себя вся система в деталях, прежде чем мы начнём работу. Мы постепенно записываем свои ожидания по кусочкам в виде тестов, и удовлетворяем эти ожидания step by step в виде дополнений и изменений в коде.

Задание 1.

Составьте предварительное, самое общее, словесное описание системы, которую вы хотите сделать. Придерживаясь принципов модульности, определите в ней 5-7 наиболее общих сущностей (потенциальных АТД), пока кратко и неформально их опишите.

Укажите, что делает в системе каждая такая сущность, стараясь, чтобы из этого множества формулировок "кто что делает" была бы хорошо понятна и общая идея работы системы в целом.
